"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Server = void 0;
const typedi_1 = require("typedi");
const child_process_1 = require("child_process");
const promises_1 = require("fs/promises");
const util_1 = require("util");
const cookie_parser_1 = __importDefault(require("cookie-parser"));
const express_1 = __importDefault(require("express"));
const helmet_1 = __importDefault(require("helmet"));
const n8n_core_1 = require("n8n-core");
const google_timezones_json_1 = __importDefault(require("google-timezones-json"));
const config_1 = __importDefault(require("./config"));
const Queue_1 = require("./Queue");
const workflows_controller_1 = require("./workflows/workflows.controller");
const constants_1 = require("./constants");
const credentials_controller_1 = require("./credentials/credentials.controller");
const decorators_1 = require("./decorators");
const auth_controller_1 = require("./controllers/auth.controller");
const binaryData_controller_1 = require("./controllers/binaryData.controller");
const curl_controller_1 = require("./controllers/curl.controller");
const dynamicNodeParameters_controller_1 = require("./controllers/dynamicNodeParameters.controller");
const me_controller_1 = require("./controllers/me.controller");
const mfa_controller_1 = require("./controllers/mfa.controller");
const nodeTypes_controller_1 = require("./controllers/nodeTypes.controller");
const oAuth1Credential_controller_1 = require("./controllers/oauth/oAuth1Credential.controller");
const oAuth2Credential_controller_1 = require("./controllers/oauth/oAuth2Credential.controller");
const owner_controller_1 = require("./controllers/owner.controller");
const passwordReset_controller_1 = require("./controllers/passwordReset.controller");
const tags_controller_1 = require("./controllers/tags.controller");
const translation_controller_1 = require("./controllers/translation.controller");
const users_controller_1 = require("./controllers/users.controller");
const workflowStatistics_controller_1 = require("./controllers/workflowStatistics.controller");
const ExternalSecrets_controller_ee_1 = require("./ExternalSecrets/ExternalSecrets.controller.ee");
const executions_controller_1 = require("./executions/executions.controller");
const PublicApi_1 = require("./PublicApi");
const CredentialsOverwrites_1 = require("./CredentialsOverwrites");
const LoadNodesAndCredentials_1 = require("./LoadNodesAndCredentials");
const ResponseHelper = __importStar(require("./ResponseHelper"));
const eventBus_controller_1 = require("./eventbus/eventBus.controller");
const eventBus_controller_ee_1 = require("./eventbus/eventBus.controller.ee");
const license_controller_1 = require("./license/license.controller");
const push_1 = require("./push");
const helpers_1 = require("./Ldap/helpers");
const AbstractServer_1 = require("./AbstractServer");
const posthog_1 = require("./posthog");
const MessageEventBus_1 = require("./eventbus/MessageEventBus/MessageEventBus");
const InternalHooks_1 = require("./InternalHooks");
const saml_controller_ee_1 = require("./sso/saml/routes/saml.controller.ee");
const saml_service_ee_1 = require("./sso/saml/saml.service.ee");
const variables_controller_ee_1 = require("./environments/variables/variables.controller.ee");
const sourceControl_service_ee_1 = require("./environments/sourceControl/sourceControl.service.ee");
const sourceControl_controller_ee_1 = require("./environments/sourceControl/sourceControl.controller.ee");
const ai_controller_1 = require("./controllers/ai.controller");
const helpers_2 = require("./Mfa/helpers");
const activeWorkflows_controller_1 = require("./controllers/activeWorkflows.controller");
const orchestration_controller_1 = require("./controllers/orchestration.controller");
const workflowHistory_controller_ee_1 = require("./workflows/workflowHistory/workflowHistory.controller.ee");
const invitation_controller_1 = require("./controllers/invitation.controller");
const orchestration_service_1 = require("./services/orchestration.service");
const project_controller_1 = require("./controllers/project.controller");
const role_controller_1 = require("./controllers/role.controller");
const exec = (0, util_1.promisify)(child_process_1.exec);
let Server = class Server extends AbstractServer_1.AbstractServer {
    constructor() {
        super('main');
        this.testWebhooksEnabled = true;
        this.webhooksEnabled = !config_1.default.getEnv('endpoints.disableProductionWebhooksOnMainProcess');
    }
    async start() {
        this.loadNodesAndCredentials = typedi_1.Container.get(LoadNodesAndCredentials_1.LoadNodesAndCredentials);
        if (!config_1.default.getEnv('endpoints.disableUi')) {
            this.frontendService = typedi_1.Container.get(require('./services/frontend.service').FrontendService);
        }
        this.presetCredentialsLoaded = false;
        this.endpointPresetCredentials = config_1.default.getEnv('credentials.overwrite.endpoint');
        await super.start();
        this.logger.debug(`Server ID: ${this.uniqueInstanceId}`);
        if (constants_1.inDevelopment && process.env.N8N_DEV_RELOAD === 'true') {
            void this.loadNodesAndCredentials.setupHotReload();
        }
        void typedi_1.Container.get(InternalHooks_1.InternalHooks).onServerStarted();
    }
    async registerControllers() {
        const { app } = this;
        const controllers = [
            eventBus_controller_1.EventBusController,
            eventBus_controller_ee_1.EventBusControllerEE,
            auth_controller_1.AuthController,
            license_controller_1.LicenseController,
            oAuth1Credential_controller_1.OAuth1CredentialController,
            oAuth2Credential_controller_1.OAuth2CredentialController,
            owner_controller_1.OwnerController,
            me_controller_1.MeController,
            dynamicNodeParameters_controller_1.DynamicNodeParametersController,
            nodeTypes_controller_1.NodeTypesController,
            passwordReset_controller_1.PasswordResetController,
            tags_controller_1.TagsController,
            translation_controller_1.TranslationController,
            users_controller_1.UsersController,
            saml_controller_ee_1.SamlController,
            sourceControl_controller_ee_1.SourceControlController,
            workflowStatistics_controller_1.WorkflowStatisticsController,
            ExternalSecrets_controller_ee_1.ExternalSecretsController,
            orchestration_controller_1.OrchestrationController,
            workflowHistory_controller_ee_1.WorkflowHistoryController,
            binaryData_controller_1.BinaryDataController,
            variables_controller_ee_1.VariablesController,
            invitation_controller_1.InvitationController,
            variables_controller_ee_1.VariablesController,
            activeWorkflows_controller_1.ActiveWorkflowsController,
            workflows_controller_1.WorkflowsController,
            executions_controller_1.ExecutionsController,
            credentials_controller_1.CredentialsController,
            ai_controller_1.AIController,
            project_controller_1.ProjectController,
            role_controller_1.RoleController,
            curl_controller_1.CurlController,
        ];
        if (process.env.NODE_ENV !== 'production' &&
            typedi_1.Container.get(orchestration_service_1.OrchestrationService).isMultiMainSetupEnabled) {
            const { DebugController } = await Promise.resolve().then(() => __importStar(require('./controllers/debug.controller')));
            controllers.push(DebugController);
        }
        if ((0, helpers_1.isLdapEnabled)()) {
            const { LdapService } = await Promise.resolve().then(() => __importStar(require('./Ldap/ldap.service')));
            const { LdapController } = await require('./Ldap/ldap.controller');
            await typedi_1.Container.get(LdapService).init();
            controllers.push(LdapController);
        }
        if (config_1.default.getEnv('nodes.communityPackages.enabled')) {
            const { CommunityPackagesController } = await Promise.resolve().then(() => __importStar(require('./controllers/communityPackages.controller')));
            controllers.push(CommunityPackagesController);
        }
        if (constants_1.inE2ETests) {
            const { E2EController } = await Promise.resolve().then(() => __importStar(require('./controllers/e2e.controller')));
            controllers.push(E2EController);
        }
        if ((0, helpers_2.isMfaFeatureEnabled)()) {
            controllers.push(mfa_controller_1.MFAController);
        }
        if (!config_1.default.getEnv('endpoints.disableUi')) {
            const { CtaController } = await Promise.resolve().then(() => __importStar(require('./controllers/cta.controller')));
            controllers.push(CtaController);
        }
        controllers.forEach((controller) => (0, decorators_1.registerController)(app, controller));
    }
    async configure() {
        if (config_1.default.getEnv('endpoints.metrics.enable')) {
            const { MetricsService } = await Promise.resolve().then(() => __importStar(require('./services/metrics.service')));
            await typedi_1.Container.get(MetricsService).configureMetrics(this.app);
        }
        const { frontendService } = this;
        if (frontendService) {
            frontendService.addToSettings({
                isNpmAvailable: await exec('npm --version')
                    .then(() => true)
                    .catch(() => false),
                versionCli: constants_1.N8N_VERSION,
            });
            await this.externalHooks.run('frontend.settings', [frontendService.getSettings()]);
        }
        await typedi_1.Container.get(posthog_1.PostHogClient).init();
        const publicApiEndpoint = config_1.default.getEnv('publicApi.path');
        if ((0, PublicApi_1.isApiEnabled)()) {
            const { apiRouters, apiLatestVersion } = await (0, PublicApi_1.loadPublicApiVersions)(publicApiEndpoint);
            this.app.use(...apiRouters);
            if (frontendService) {
                frontendService.settings.publicApi.latestVersion = apiLatestVersion;
            }
        }
        this.app.use((req, _, next) => {
            req.browserId = req.headers['browser-id'];
            next();
        });
        this.app.use((0, cookie_parser_1.default)());
        const { restEndpoint, app } = this;
        (0, push_1.setupPushHandler)(restEndpoint, app);
        if (config_1.default.getEnv('executions.mode') === 'queue') {
            await typedi_1.Container.get(Queue_1.Queue).init();
        }
        await (0, helpers_2.handleMfaDisable)();
        await this.registerControllers();
        try {
            await typedi_1.Container.get(saml_service_ee_1.SamlService).init();
        }
        catch (error) {
            this.logger.warn(`SAML initialization failed: ${error.message}`);
        }
        try {
            await typedi_1.Container.get(sourceControl_service_ee_1.SourceControlService).init();
        }
        catch (error) {
            this.logger.warn(`Source Control initialization failed: ${error.message}`);
        }
        this.app.get(`/${this.restEndpoint}/options/timezones`, ResponseHelper.send(async () => google_timezones_json_1.default));
        if (frontendService) {
            this.app.get(`/${this.restEndpoint}/settings`, ResponseHelper.send(async (req) => frontendService.getSettings(req.headers['push-ref'])));
        }
        const eventBus = typedi_1.Container.get(MessageEventBus_1.MessageEventBus);
        await eventBus.initialize();
        if (this.endpointPresetCredentials !== '') {
            this.app.post(`/${this.endpointPresetCredentials}`, async (req, res) => {
                if (!this.presetCredentialsLoaded) {
                    const body = req.body;
                    if (req.contentType !== 'application/json') {
                        ResponseHelper.sendErrorResponse(res, new Error('Body must be a valid JSON, make sure the content-type is application/json'));
                        return;
                    }
                    typedi_1.Container.get(CredentialsOverwrites_1.CredentialsOverwrites).setData(body);
                    await (frontendService === null || frontendService === void 0 ? void 0 : frontendService.generateTypes());
                    this.presetCredentialsLoaded = true;
                    ResponseHelper.sendSuccessResponse(res, { success: true }, true, 200);
                }
                else {
                    ResponseHelper.sendErrorResponse(res, new Error('Preset credentials can be set once'));
                }
            });
        }
        const maxAge = constants_1.Time.days.toMilliseconds;
        const cacheOptions = constants_1.inE2ETests || constants_1.inDevelopment ? {} : { maxAge };
        const { staticCacheDir } = typedi_1.Container.get(n8n_core_1.InstanceSettings);
        if (frontendService) {
            const serveIcons = async (req, res) => {
                let { scope, packageName } = req.params;
                if (scope)
                    packageName = `@${scope}/${packageName}`;
                const filePath = this.loadNodesAndCredentials.resolveIcon(packageName, req.originalUrl);
                if (filePath) {
                    try {
                        await (0, promises_1.access)(filePath);
                        return res.sendFile(filePath, cacheOptions);
                    }
                    catch { }
                }
                res.sendStatus(404);
            };
            this.app.use('/icons/@:scope/:packageName/*/*.(svg|png)', serveIcons);
            this.app.use('/icons/:packageName/*/*.(svg|png)', serveIcons);
            const isTLSEnabled = this.protocol === 'https' && !!(this.sslKey && this.sslCert);
            const isPreviewMode = process.env.N8N_PREVIEW_MODE === 'true';
            const securityHeadersMiddleware = (0, helmet_1.default)({
                contentSecurityPolicy: false,
                xFrameOptions: isPreviewMode || constants_1.inE2ETests || constants_1.inDevelopment ? false : { action: 'sameorigin' },
                dnsPrefetchControl: false,
                ieNoOpen: false,
                xPoweredBy: false,
                strictTransportSecurity: isTLSEnabled
                    ? {
                        maxAge: 180 * constants_1.Time.days.toSeconds,
                        includeSubDomains: false,
                        preload: false,
                    }
                    : false,
            });
            const nonUIRoutes = [
                'assets',
                'types',
                'healthz',
                'metrics',
                'e2e',
                this.restEndpoint,
                this.endpointPresetCredentials,
                (0, PublicApi_1.isApiEnabled)() ? '' : publicApiEndpoint,
                ...config_1.default.getEnv('endpoints.additionalNonUIRoutes').split(':'),
            ].filter((u) => !!u);
            const nonUIRoutesRegex = new RegExp(`^/(${nonUIRoutes.join('|')})/?.*$`);
            const historyApiHandler = (req, res, next) => {
                const { method, headers: { accept }, } = req;
                if (method === 'GET' &&
                    accept &&
                    (accept.includes('text/html') || accept.includes('*/*')) &&
                    !nonUIRoutesRegex.test(req.path)) {
                    res.setHeader('Cache-Control', 'no-cache, no-store, must-revalidate');
                    securityHeadersMiddleware(req, res, () => {
                        res.sendFile('index.html', { root: staticCacheDir, maxAge, lastModified: true });
                    });
                }
                else {
                    next();
                }
            };
            this.app.use('/', express_1.default.static(staticCacheDir, cacheOptions), express_1.default.static(constants_1.EDITOR_UI_DIST_DIR, cacheOptions), historyApiHandler);
        }
        else {
            this.app.use('/', express_1.default.static(staticCacheDir, cacheOptions));
        }
    }
    setupPushServer() {
        const { restEndpoint, server, app } = this;
        (0, push_1.setupPushServer)(restEndpoint, server, app);
    }
};
exports.Server = Server;
exports.Server = Server = __decorate([
    (0, typedi_1.Service)(),
    __metadata("design:paramtypes", [])
], Server);
//# sourceMappingURL=Server.js.map