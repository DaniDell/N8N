{"version":3,"file":"nodeCreator.store-DR3dfsvW.js","sources":["../../src/utils/sortUtils.ts","../../src/components/Node/NodeCreator/utils.ts","../../src/stores/nodeCreator.store.ts"],"sourcesContent":["/*\n\tConstants and utility functions used for searching for node types in node creator component\n*/\n\n// based on https://github.com/forrestthewoods/lib_fts/blob/master/code/fts_fuzzy_match.js\n\nconst SEQUENTIAL_BONUS = 60; // bonus for adjacent matches\nconst SEPARATOR_BONUS = 30; // bonus if match occurs after a separator\nconst CAMEL_BONUS = 30; // bonus if match is uppercase and prev is lower\nconst FIRST_LETTER_BONUS = 15; // bonus if the first letter is matched\n\nconst LEADING_LETTER_PENALTY = -20; // penalty applied for every letter in str before the first match\nconst MAX_LEADING_LETTER_PENALTY = -200; // maximum penalty for leading letters\nconst UNMATCHED_LETTER_PENALTY = -5;\n\n/**\n * Returns true if each character in pattern is found sequentially within target\n * @param {*} pattern string\n * @param {*} target string\n */\nfunction fuzzyMatchSimple(pattern: string, target: string): boolean {\n\tlet patternIdx = 0;\n\tlet strIdx = 0;\n\n\twhile (patternIdx < pattern.length && strIdx < target.length) {\n\t\tconst patternChar = pattern.charAt(patternIdx).toLowerCase();\n\t\tconst targetChar = target.charAt(strIdx).toLowerCase();\n\t\tif (patternChar === targetChar) {\n\t\t\tpatternIdx++;\n\t\t}\n\t\t++strIdx;\n\t}\n\n\treturn pattern.length !== 0 && target.length !== 0 && patternIdx === pattern.length;\n}\n\n/**\n * Does a fuzzy search to find pattern inside a string.\n * @param {*} pattern string        pattern to search for\n * @param {*} target     string        string which is being searched\n * @returns [boolean, number]       a boolean which tells if pattern was\n *                                  found or not and a search score\n */\nfunction fuzzyMatch(pattern: string, target: string): { matched: boolean; outScore: number } {\n\tconst recursionCount = 0;\n\tconst recursionLimit = 5;\n\tconst matches: number[] = [];\n\tconst maxMatches = 256;\n\n\treturn fuzzyMatchRecursive(\n\t\tpattern,\n\t\ttarget,\n\t\t0 /* patternCurIndex */,\n\t\t0 /* strCurrIndex */,\n\t\tnull /* srcMatces */,\n\t\tmatches,\n\t\tmaxMatches,\n\t\t0 /* nextMatch */,\n\t\trecursionCount,\n\t\trecursionLimit,\n\t);\n}\n\nfunction fuzzyMatchRecursive(\n\tpattern: string,\n\ttarget: string,\n\tpatternCurIndex: number,\n\ttargetCurrIndex: number,\n\ttargetMatches: null | number[],\n\tmatches: number[],\n\tmaxMatches: number,\n\tnextMatch: number,\n\trecursionCount: number,\n\trecursionLimit: number,\n): { matched: boolean; outScore: number } {\n\tlet outScore = 0;\n\n\t// Return if recursion limit is reached.\n\tif (++recursionCount >= recursionLimit) {\n\t\treturn { matched: false, outScore };\n\t}\n\n\t// Return if we reached ends of strings.\n\tif (patternCurIndex === pattern.length || targetCurrIndex === target.length) {\n\t\treturn { matched: false, outScore };\n\t}\n\n\t// Recursion params\n\tlet recursiveMatch = false;\n\tlet bestRecursiveMatches: number[] = [];\n\tlet bestRecursiveScore = 0;\n\n\t// Loop through pattern and str looking for a match.\n\tlet firstMatch = true;\n\twhile (patternCurIndex < pattern.length && targetCurrIndex < target.length) {\n\t\t// Match found.\n\t\tif (pattern[patternCurIndex].toLowerCase() === target[targetCurrIndex].toLowerCase()) {\n\t\t\tif (nextMatch >= maxMatches) {\n\t\t\t\treturn { matched: false, outScore };\n\t\t\t}\n\n\t\t\tif (firstMatch && targetMatches) {\n\t\t\t\tmatches = [...targetMatches];\n\t\t\t\tfirstMatch = false;\n\t\t\t}\n\n\t\t\tconst recursiveMatches: number[] = [];\n\t\t\tconst recursiveResult = fuzzyMatchRecursive(\n\t\t\t\tpattern,\n\t\t\t\ttarget,\n\t\t\t\tpatternCurIndex,\n\t\t\t\ttargetCurrIndex + 1,\n\t\t\t\tmatches,\n\t\t\t\trecursiveMatches,\n\t\t\t\tmaxMatches,\n\t\t\t\tnextMatch,\n\t\t\t\trecursionCount,\n\t\t\t\trecursionLimit,\n\t\t\t);\n\n\t\t\tconst recursiveScore = recursiveResult.outScore;\n\t\t\tif (recursiveResult.matched) {\n\t\t\t\t// Pick best recursive score.\n\t\t\t\tif (!recursiveMatch || recursiveScore > bestRecursiveScore) {\n\t\t\t\t\tbestRecursiveMatches = [...recursiveMatches];\n\t\t\t\t\tbestRecursiveScore = recursiveScore;\n\t\t\t\t}\n\t\t\t\trecursiveMatch = true;\n\t\t\t}\n\n\t\t\tmatches[nextMatch++] = targetCurrIndex;\n\t\t\t++patternCurIndex;\n\t\t}\n\t\t++targetCurrIndex;\n\t}\n\n\tconst matched = patternCurIndex === pattern.length;\n\n\tif (matched) {\n\t\toutScore = 100;\n\n\t\t// Apply leading letter penalty\n\t\tlet penalty = LEADING_LETTER_PENALTY * matches[0];\n\t\tpenalty = penalty < MAX_LEADING_LETTER_PENALTY ? MAX_LEADING_LETTER_PENALTY : penalty;\n\t\toutScore += penalty;\n\n\t\t//Apply unmatched penalty\n\t\tconst unmatched = target.length - nextMatch;\n\t\toutScore += UNMATCHED_LETTER_PENALTY * unmatched;\n\n\t\t// Apply ordering bonuses\n\t\tfor (let i = 0; i < nextMatch; i++) {\n\t\t\tconst currIdx = matches[i];\n\n\t\t\tif (i > 0) {\n\t\t\t\tconst prevIdx = matches[i - 1];\n\t\t\t\tif (currIdx === prevIdx + 1) {\n\t\t\t\t\toutScore += SEQUENTIAL_BONUS;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check for bonuses based on neighbor character value.\n\t\t\tif (currIdx > 0) {\n\t\t\t\t// Camel case\n\t\t\t\tconst neighbor = target[currIdx - 1];\n\t\t\t\tconst curr = target[currIdx];\n\t\t\t\tif (neighbor !== neighbor.toUpperCase() && curr !== curr.toLowerCase()) {\n\t\t\t\t\toutScore += CAMEL_BONUS;\n\t\t\t\t}\n\t\t\t\tconst isNeighbourSeparator = neighbor === '_' || neighbor === ' ';\n\t\t\t\tif (isNeighbourSeparator) {\n\t\t\t\t\toutScore += SEPARATOR_BONUS;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// First letter\n\t\t\t\toutScore += FIRST_LETTER_BONUS;\n\t\t\t}\n\t\t}\n\n\t\t// Return best result\n\t\tif (recursiveMatch && (!matched || bestRecursiveScore > outScore)) {\n\t\t\t// Recursive score is better than \"this\"\n\t\t\tmatches = [...bestRecursiveMatches];\n\t\t\toutScore = bestRecursiveScore;\n\t\t\treturn { matched: true, outScore };\n\t\t} else if (matched) {\n\t\t\t// \"this\" score is better than recursive\n\t\t\treturn { matched: true, outScore };\n\t\t} else {\n\t\t\treturn { matched: false, outScore };\n\t\t}\n\t}\n\treturn { matched: false, outScore };\n}\n\n// prop = 'key'\n// prop = 'key1.key2'\n// prop = ['key1', 'key2']\nfunction getValue<T extends object>(obj: T, prop: string): unknown {\n\tif (obj.hasOwnProperty(prop)) {\n\t\treturn obj[prop as keyof T];\n\t}\n\n\tconst segments = prop.split('.');\n\n\tlet result = obj;\n\tlet i = 0;\n\twhile (result && i < segments.length) {\n\t\tconst key = segments[i] as keyof T;\n\t\tresult = result[key] as T;\n\t\ti++;\n\t}\n\treturn result;\n}\n\nexport function sublimeSearch<T extends object>(\n\tfilter: string,\n\tdata: Readonly<T[]>,\n\tkeys: Array<{ key: string; weight: number }>,\n): Array<{ score: number; item: T }> {\n\tconst results = data.reduce((accu: Array<{ score: number; item: T }>, item: T) => {\n\t\tlet values: Array<{ value: string; weight: number }> = [];\n\t\tkeys.forEach(({ key, weight }) => {\n\t\t\tconst value = getValue(item, key);\n\t\t\tif (Array.isArray(value)) {\n\t\t\t\tvalues = values.concat(value.map((v) => ({ value: v, weight })));\n\t\t\t} else if (typeof value === 'string') {\n\t\t\t\tvalues.push({\n\t\t\t\t\tvalue,\n\t\t\t\t\tweight,\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\t// for each item, check every key and get maximum score\n\t\tconst itemMatch = values.reduce(\n\t\t\t(\n\t\t\t\taccu: null | { matched: boolean; outScore: number },\n\t\t\t\t{ value, weight }: { value: string; weight: number },\n\t\t\t) => {\n\t\t\t\tif (!fuzzyMatchSimple(filter, value)) {\n\t\t\t\t\treturn accu;\n\t\t\t\t}\n\n\t\t\t\tconst match = fuzzyMatch(filter, value);\n\t\t\t\tmatch.outScore *= weight;\n\n\t\t\t\tconst { matched, outScore } = match;\n\t\t\t\tif (!accu && matched) {\n\t\t\t\t\treturn match;\n\t\t\t\t}\n\t\t\t\tif (matched && accu && outScore > accu.outScore) {\n\t\t\t\t\treturn match;\n\t\t\t\t}\n\t\t\t\treturn accu;\n\t\t\t},\n\t\t\tnull,\n\t\t);\n\n\t\tif (itemMatch) {\n\t\t\taccu.push({\n\t\t\t\tscore: itemMatch.outScore,\n\t\t\t\titem,\n\t\t\t});\n\t\t}\n\n\t\treturn accu;\n\t}, []);\n\n\tresults.sort((a, b) => {\n\t\treturn b.score - a.score;\n\t});\n\n\treturn results;\n}\n","import type {\n\tNodeCreateElement,\n\tActionCreateElement,\n\tSubcategorizedNodeTypes,\n\tSimplifiedNodeType,\n\tINodeCreateElement,\n\tSectionCreateElement,\n} from '@/Interface';\nimport {\n\tAI_CATEGORY_AGENTS,\n\tAI_SUBCATEGORY,\n\tCORE_NODES_CATEGORY,\n\tDEFAULT_SUBCATEGORY,\n} from '@/constants';\nimport { v4 as uuidv4 } from 'uuid';\n\nimport { sublimeSearch } from '@/utils/sortUtils';\nimport type { NodeViewItemSection } from './viewsData';\nimport { i18n } from '@/plugins/i18n';\nimport { sortBy } from 'lodash-es';\n\nexport function transformNodeType(\n\tnode: SimplifiedNodeType,\n\tsubcategory?: string,\n\ttype: 'node' | 'action' = 'node',\n): NodeCreateElement | ActionCreateElement {\n\tconst createElement = {\n\t\tuuid: uuidv4(),\n\t\tkey: node.name,\n\t\tsubcategory:\n\t\t\tsubcategory ?? node.codex?.subcategories?.[CORE_NODES_CATEGORY]?.[0] ?? DEFAULT_SUBCATEGORY,\n\t\tproperties: {\n\t\t\t...node,\n\t\t},\n\t\ttype,\n\t};\n\n\treturn type === 'action'\n\t\t? (createElement as ActionCreateElement)\n\t\t: (createElement as NodeCreateElement);\n}\n\nexport function subcategorizeItems(items: SimplifiedNodeType[]) {\n\tconst WHITE_LISTED_SUBCATEGORIES = [CORE_NODES_CATEGORY, AI_SUBCATEGORY];\n\treturn items.reduce((acc: SubcategorizedNodeTypes, item) => {\n\t\t// Only some subcategories are allowed\n\t\tlet subcategories: string[] = [DEFAULT_SUBCATEGORY];\n\n\t\tWHITE_LISTED_SUBCATEGORIES.forEach((category) => {\n\t\t\tif (item.codex?.categories?.includes(category)) {\n\t\t\t\tsubcategories = item.codex?.subcategories?.[category] ?? [];\n\t\t\t}\n\t\t});\n\n\t\tsubcategories.forEach((subcategory: string) => {\n\t\t\tif (!acc[subcategory]) {\n\t\t\t\tacc[subcategory] = [];\n\t\t\t}\n\t\t\tacc[subcategory].push(transformNodeType(item, subcategory));\n\t\t});\n\n\t\treturn acc;\n\t}, {});\n}\n\nexport function sortNodeCreateElements(nodes: INodeCreateElement[]) {\n\treturn nodes.sort((a, b) => {\n\t\tif (a.type !== 'node' || b.type !== 'node') return 0;\n\t\tconst displayNameA = a.properties?.displayName?.toLowerCase() || a.key;\n\t\tconst displayNameB = b.properties?.displayName?.toLowerCase() || b.key;\n\n\t\treturn displayNameA.localeCompare(displayNameB, undefined, { sensitivity: 'base' });\n\t});\n}\n\nexport function searchNodes(searchFilter: string, items: INodeCreateElement[]) {\n\t// In order to support the old search we need to remove the 'trigger' part\n\tconst trimmedFilter = searchFilter.toLowerCase().replace('trigger', '').trimEnd();\n\n\tconst result = (\n\t\tsublimeSearch<INodeCreateElement>(trimmedFilter, items, [\n\t\t\t{ key: 'properties.displayName', weight: 1.3 },\n\t\t\t{ key: 'properties.codex.alias', weight: 1 },\n\t\t]) || []\n\t).map(({ item }) => item);\n\n\treturn result;\n}\n\nexport function flattenCreateElements(items: INodeCreateElement[]): INodeCreateElement[] {\n\treturn items.map((item) => (item.type === 'section' ? item.children : item)).flat();\n}\nexport function isAINode(node: INodeCreateElement) {\n\tconst isNode = node.type === 'node';\n\tif (!isNode) return false;\n\n\tif (node.properties.codex?.categories?.includes(AI_SUBCATEGORY)) {\n\t\tconst isAgentSubcategory =\n\t\t\tnode.properties.codex?.subcategories?.[AI_SUBCATEGORY]?.includes(AI_CATEGORY_AGENTS);\n\n\t\treturn !isAgentSubcategory;\n\t}\n\n\treturn false;\n}\nexport function groupItemsInSections(\n\titems: INodeCreateElement[],\n\tsections: string[] | NodeViewItemSection[],\n\tsortAlphabetically = true,\n): INodeCreateElement[] {\n\tconst filteredSections = sections.filter(\n\t\t(section): section is NodeViewItemSection => typeof section === 'object',\n\t);\n\n\tconst itemsBySection = (items2: INodeCreateElement[]) =>\n\t\titems2.reduce((acc: Record<string, INodeCreateElement[]>, item) => {\n\t\t\tconst section = filteredSections.find((s) => s.items.includes(item.key));\n\n\t\t\tconst key = section?.key ?? 'other';\n\t\t\tif (key) {\n\t\t\t\tacc[key] = [...(acc[key] ?? []), item];\n\t\t\t}\n\t\t\treturn acc;\n\t\t}, {});\n\n\tconst mapNewSections = (\n\t\tnewSections: NodeViewItemSection[],\n\t\tchildren: Record<string, INodeCreateElement[]>,\n\t) =>\n\t\tnewSections.map(\n\t\t\t(section): SectionCreateElement => ({\n\t\t\t\ttype: 'section',\n\t\t\t\tkey: section.key,\n\t\t\t\ttitle: section.title,\n\t\t\t\tchildren: sortAlphabetically\n\t\t\t\t\t? sortNodeCreateElements(children[section.key] ?? [])\n\t\t\t\t\t: children[section.key] ?? [],\n\t\t\t}),\n\t\t);\n\n\tconst nonAINodes = items.filter((item) => !isAINode(item));\n\tconst AINodes = items.filter((item) => isAINode(item));\n\n\tconst nonAINodesBySection = itemsBySection(nonAINodes);\n\tconst nonAINodesSections = mapNewSections(filteredSections, nonAINodesBySection);\n\n\tconst AINodesBySection = itemsBySection(AINodes);\n\n\tconst AINodesSections = mapNewSections(sortBy(filteredSections, ['title']), AINodesBySection);\n\n\tconst result = [...nonAINodesSections, ...AINodesSections]\n\t\t.concat({\n\t\t\ttype: 'section',\n\t\t\tkey: 'other',\n\t\t\ttitle: i18n.baseText('nodeCreator.sectionNames.other'),\n\t\t\tchildren: sortNodeCreateElements(nonAINodesBySection.other ?? []),\n\t\t})\n\t\t.filter((section) => section.type !== 'section' || section.children.length > 0);\n\n\tif (result.length <= 1) {\n\t\treturn items;\n\t}\n\n\treturn result;\n}\n","import { defineStore } from 'pinia';\nimport { STORES, TRIGGER_NODE_CREATOR_VIEW } from '@/constants';\nimport type {\n\tNodeFilterType,\n\tNodeCreatorOpenSource,\n\tSimplifiedNodeType,\n\tActionsRecord,\n} from '@/Interface';\n\nimport { computed, ref } from 'vue';\nimport { transformNodeType } from '@/components/Node/NodeCreator/utils';\n\nexport const useNodeCreatorStore = defineStore(STORES.NODE_CREATOR, () => {\n\tconst selectedView = ref<NodeFilterType>(TRIGGER_NODE_CREATOR_VIEW);\n\tconst mergedNodes = ref<SimplifiedNodeType[]>([]);\n\tconst actions = ref<ActionsRecord<typeof mergedNodes.value>>({});\n\n\tconst showScrim = ref(false);\n\tconst openSource = ref<NodeCreatorOpenSource>('');\n\n\tconst allNodeCreatorNodes = computed(() =>\n\t\tObject.values(mergedNodes.value).map((i) => transformNodeType(i)),\n\t);\n\n\tfunction setMergeNodes(nodes: SimplifiedNodeType[]) {\n\t\tmergedNodes.value = nodes;\n\t}\n\n\tfunction setActions(nodes: ActionsRecord<typeof mergedNodes.value>) {\n\t\tactions.value = nodes;\n\t}\n\n\tfunction setShowScrim(isVisible: boolean) {\n\t\tshowScrim.value = isVisible;\n\t}\n\n\tfunction setSelectedView(view: NodeFilterType) {\n\t\tselectedView.value = view;\n\t}\n\n\tfunction setOpenSource(view: NodeCreatorOpenSource) {\n\t\topenSource.value = view;\n\t}\n\n\treturn {\n\t\topenSource,\n\t\tselectedView,\n\t\tshowScrim,\n\t\tmergedNodes,\n\t\tactions,\n\t\tsetShowScrim,\n\t\tsetSelectedView,\n\t\tsetOpenSource,\n\t\tsetActions,\n\t\tsetMergeNodes,\n\t\tallNodeCreatorNodes,\n\t};\n});\n"],"names":["SEQUENTIAL_BONUS","SEPARATOR_BONUS","CAMEL_BONUS","FIRST_LETTER_BONUS","LEADING_LETTER_PENALTY","MAX_LEADING_LETTER_PENALTY","UNMATCHED_LETTER_PENALTY","fuzzyMatchSimple","pattern","target","patternIdx","strIdx","patternChar","targetChar","fuzzyMatch","fuzzyMatchRecursive","patternCurIndex","targetCurrIndex","targetMatches","matches","maxMatches","nextMatch","recursionCount","recursionLimit","outScore","recursiveMatch","bestRecursiveMatches","bestRecursiveScore","firstMatch","recursiveMatches","recursiveResult","recursiveScore","matched","penalty","unmatched","i","currIdx","prevIdx","neighbor","curr","getValue","obj","prop","segments","result","key","sublimeSearch","filter","data","keys","results","accu","item","values","weight","value","v","itemMatch","match","a","b","transformNodeType","node","subcategory","type","createElement","uuidv4","_c","_b","_a","CORE_NODES_CATEGORY","DEFAULT_SUBCATEGORY","subcategorizeItems","items","WHITE_LISTED_SUBCATEGORIES","AI_SUBCATEGORY","acc","subcategories","category","_d","sortNodeCreateElements","nodes","displayNameA","displayNameB","searchNodes","searchFilter","trimmedFilter","flattenCreateElements","isAINode","_e","AI_CATEGORY_AGENTS","groupItemsInSections","sections","sortAlphabetically","filteredSections","section","itemsBySection","items2","s","mapNewSections","newSections","children","nonAINodes","AINodes","nonAINodesBySection","nonAINodesSections","AINodesBySection","AINodesSections","sortBy","i18n","useNodeCreatorStore","defineStore","STORES","selectedView","ref","TRIGGER_NODE_CREATOR_VIEW","mergedNodes","actions","showScrim","openSource","allNodeCreatorNodes","computed","setMergeNodes","setActions","setShowScrim","isVisible","setSelectedView","view","setOpenSource"],"mappings":"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"}